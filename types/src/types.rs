// Code generated by oto; DO NOT EDIT.
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json::{Map, Value};

#[async_trait]
pub trait AudioInterface: std::marker::Send + std::marker::Sync {
    async fn create_stream(&self, req: CreateStreamRequest)
        -> Result<CreateStreamResponse, String>;
    async fn delete_stream(&self, req: DeleteStreamRequest)
        -> Result<DeleteStreamResponse, String>;
    async fn get_device_info(
        &self,
        req: GetDeviceInfoRequest,
    ) -> Result<GetDeviceInfoResponse, String>;
    async fn list_streams(&self, req: ListStreamsRequest) -> Result<ListStreamsResponse, String>;
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Address {
    #[serde(rename = "host")]
    pub host: String,
    #[serde(rename = "port")]
    pub port: i64,
}

impl Address {
    pub fn new() -> Self {
        Address {
            host: String::new(),
            port: std::default::Default::default(),
        }
    }

    pub fn make(host: String, port: i64) -> Self {
        Address { host, port }
    }
}

impl Default for Address {
    fn default() -> Address {
        Address::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct HardwarePort {
    #[serde(rename = "channel")]
    pub channel: i64,
    #[serde(rename = "sampleRate")]
    pub sample_rate: i64,
    #[serde(rename = "sampleFormat")]
    pub sample_format: String,
}

impl HardwarePort {
    pub fn new() -> Self {
        HardwarePort {
            channel: std::default::Default::default(),
            sample_rate: std::default::Default::default(),
            sample_format: String::new(),
        }
    }

    pub fn make(channel: i64, sample_rate: i64, sample_format: String) -> Self {
        HardwarePort {
            channel,

            sample_rate,

            sample_format,
        }
    }
}

impl Default for HardwarePort {
    fn default() -> HardwarePort {
        HardwarePort::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Stream {
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "isOutput")]
    pub is_output: bool,
    #[serde(rename = "address")]
    pub address: Address,
    #[serde(rename = "hardwarePort")]
    pub hardware_port: HardwarePort,
}

impl Stream {
    pub fn new() -> Self {
        Stream {
            name: String::new(),
            is_output: Default::default(),
            address: Default::default(),
            hardware_port: Default::default(),
        }
    }

    pub fn make(
        name: String,
        is_output: bool,
        address: Address,
        hardware_port: HardwarePort,
    ) -> Self {
        Stream {
            name,

            is_output,

            address,

            hardware_port,
        }
    }
}

impl Default for Stream {
    fn default() -> Stream {
        Stream::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct CreateStreamRequest {
    #[serde(rename = "stream")]
    pub stream: Stream,
}

impl CreateStreamRequest {
    pub fn new() -> Self {
        CreateStreamRequest {
            stream: Default::default(),
        }
    }

    pub fn make(stream: Stream) -> Self {
        CreateStreamRequest { stream }
    }
}

impl Default for CreateStreamRequest {
    fn default() -> CreateStreamRequest {
        CreateStreamRequest::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct CreateStreamResponse {
    #[serde(rename = "created")]
    pub created: String,
    #[serde(rename = "error")]
    error: Option<String>,
}

impl CreateStreamResponse {
    pub fn new() -> Self {
        CreateStreamResponse {
            created: String::new(),
            error: None,
        }
    }

    pub fn make(created: String, error: Option<String>) -> Self {
        CreateStreamResponse { created, error }
    }

    pub fn error(msg: String) -> Self {
        CreateStreamResponse {
            error: Some(msg),

            created: Default::default(),
        }
    }

    pub(crate) fn is_error(&self) -> bool {
        self.error != None
    }

    pub(crate) fn get_error(&self) -> Option<&String> {
        self.error.as_ref()
    }

    pub(crate) fn take_error(&mut self) -> Option<String> {
        self.error.take()
    }
}

impl Default for CreateStreamResponse {
    fn default() -> CreateStreamResponse {
        CreateStreamResponse::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct DeleteStreamRequest {
    #[serde(rename = "name")]
    pub name: String,
}

impl DeleteStreamRequest {
    pub fn new() -> Self {
        DeleteStreamRequest {
            name: String::new(),
        }
    }

    pub fn make(name: String) -> Self {
        DeleteStreamRequest { name }
    }
}

impl Default for DeleteStreamRequest {
    fn default() -> DeleteStreamRequest {
        DeleteStreamRequest::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct DeleteStreamResponse {
    #[serde(rename = "error")]
    error: Option<String>,
}

impl DeleteStreamResponse {
    pub fn new() -> Self {
        DeleteStreamResponse { error: None }
    }

    pub fn make(error: Option<String>) -> Self {
        DeleteStreamResponse { error }
    }

    pub fn error(msg: String) -> Self {
        DeleteStreamResponse { error: Some(msg) }
    }

    pub(crate) fn is_error(&self) -> bool {
        self.error != None
    }

    pub(crate) fn get_error(&self) -> Option<&String> {
        self.error.as_ref()
    }

    pub(crate) fn take_error(&mut self) -> Option<String> {
        self.error.take()
    }
}

impl Default for DeleteStreamResponse {
    fn default() -> DeleteStreamResponse {
        DeleteStreamResponse::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct GetDeviceInfoRequest {}

impl GetDeviceInfoRequest {
    pub fn new() -> Self {
        GetDeviceInfoRequest {}
    }

    pub fn make() -> Self {
        GetDeviceInfoRequest {}
    }
}

impl Default for GetDeviceInfoRequest {
    fn default() -> GetDeviceInfoRequest {
        GetDeviceInfoRequest::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ChannelInfo {
    #[serde(rename = "sampleRates")]
    pub sample_rates: Vec<i64>,
    #[serde(rename = "desc")]
    pub desc: String,
}

impl ChannelInfo {
    pub fn new() -> Self {
        ChannelInfo {
            sample_rates: std::default::Default::default(),
            desc: String::new(),
        }
    }

    pub fn make(sample_rates: Vec<i64>, desc: String) -> Self {
        ChannelInfo { sample_rates, desc }
    }
}

impl Default for ChannelInfo {
    fn default() -> ChannelInfo {
        ChannelInfo::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct DeviceInfo {
    #[serde(rename = "channels")]
    pub channels: Vec<ChannelInfo>,
}

impl DeviceInfo {
    pub fn new() -> Self {
        DeviceInfo {
            channels: Default::default(),
        }
    }

    pub fn make(channels: Vec<ChannelInfo>) -> Self {
        DeviceInfo { channels }
    }
}

impl Default for DeviceInfo {
    fn default() -> DeviceInfo {
        DeviceInfo::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct GetDeviceInfoResponse {
    #[serde(rename = "info")]
    pub info: DeviceInfo,
    #[serde(rename = "error")]
    error: Option<String>,
}

impl GetDeviceInfoResponse {
    pub fn new() -> Self {
        GetDeviceInfoResponse {
            info: Default::default(),
            error: None,
        }
    }

    pub fn make(info: DeviceInfo, error: Option<String>) -> Self {
        GetDeviceInfoResponse { info, error }
    }

    pub fn error(msg: String) -> Self {
        GetDeviceInfoResponse {
            error: Some(msg),

            info: Default::default(),
        }
    }

    pub(crate) fn is_error(&self) -> bool {
        self.error != None
    }

    pub(crate) fn get_error(&self) -> Option<&String> {
        self.error.as_ref()
    }

    pub(crate) fn take_error(&mut self) -> Option<String> {
        self.error.take()
    }
}

impl Default for GetDeviceInfoResponse {
    fn default() -> GetDeviceInfoResponse {
        GetDeviceInfoResponse::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ListStreamsRequest {}

impl ListStreamsRequest {
    pub fn new() -> Self {
        ListStreamsRequest {}
    }

    pub fn make() -> Self {
        ListStreamsRequest {}
    }
}

impl Default for ListStreamsRequest {
    fn default() -> ListStreamsRequest {
        ListStreamsRequest::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StreamWithMetrics {
    #[serde(rename = "stream")]
    pub stream: Stream,
    #[serde(rename = "status")]
    pub status: String,
    #[serde(rename = "totalSent")]
    pub total_sent: i64,
    #[serde(rename = "totalReceived")]
    pub total_received: i64,
    #[serde(rename = "created")]
    pub created: String,
}

impl StreamWithMetrics {
    pub fn new() -> Self {
        StreamWithMetrics {
            stream: Default::default(),
            status: String::new(),
            total_sent: std::default::Default::default(),
            total_received: std::default::Default::default(),
            created: String::new(),
        }
    }

    pub fn make(
        stream: Stream,
        status: String,
        total_sent: i64,
        total_received: i64,
        created: String,
    ) -> Self {
        StreamWithMetrics {
            stream,

            status,

            total_sent,

            total_received,

            created,
        }
    }
}

impl Default for StreamWithMetrics {
    fn default() -> StreamWithMetrics {
        StreamWithMetrics::new()
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ListStreamsResponse {
    #[serde(rename = "streams")]
    pub streams: Vec<StreamWithMetrics>,
    #[serde(rename = "error")]
    error: Option<String>,
}

impl ListStreamsResponse {
    pub fn new() -> Self {
        ListStreamsResponse {
            streams: Default::default(),
            error: None,
        }
    }

    pub fn make(streams: Vec<StreamWithMetrics>, error: Option<String>) -> Self {
        ListStreamsResponse { streams, error }
    }

    pub fn error(msg: String) -> Self {
        ListStreamsResponse {
            error: Some(msg),

            streams: Default::default(),
        }
    }

    pub(crate) fn is_error(&self) -> bool {
        self.error != None
    }

    pub(crate) fn get_error(&self) -> Option<&String> {
        self.error.as_ref()
    }

    pub(crate) fn take_error(&mut self) -> Option<String> {
        self.error.take()
    }
}

impl Default for ListStreamsResponse {
    fn default() -> ListStreamsResponse {
        ListStreamsResponse::new()
    }
}

pub mod mock {
    use super::*;

    #[derive(Clone)]
    pub struct MockAudioInterface {
        error: Option<&'static str>,
    }

    impl MockAudioInterface {
        pub fn new() -> MockAudioInterface {
            MockAudioInterface { error: None }
        }

        pub fn error(message: &'static str) -> MockAudioInterface {
            MockAudioInterface {
                error: Some(message),
            }
        }
    }

    #[async_trait]
    impl AudioInterface for MockAudioInterface {
        async fn create_stream(
            &self,
            _: CreateStreamRequest,
        ) -> Result<CreateStreamResponse, String> {
            match self.error {
                Some(err) => Err(String::from(err)),
                None => Ok(Default::default()),
            }
        }

        async fn delete_stream(
            &self,
            _: DeleteStreamRequest,
        ) -> Result<DeleteStreamResponse, String> {
            match self.error {
                Some(err) => Err(String::from(err)),
                None => Ok(Default::default()),
            }
        }

        async fn get_device_info(
            &self,
            _: GetDeviceInfoRequest,
        ) -> Result<GetDeviceInfoResponse, String> {
            match self.error {
                Some(err) => Err(String::from(err)),
                None => Ok(Default::default()),
            }
        }

        async fn list_streams(&self, _: ListStreamsRequest) -> Result<ListStreamsResponse, String> {
            match self.error {
                Some(err) => Err(String::from(err)),
                None => Ok(Default::default()),
            }
        }
    }
}

#[cfg(test)]
mod test {
    use super::mock::*;
    use super::*;

    mod audio_interface {
        use super::*;

        #[tokio::test]
        async fn create_stream_ok() {
            assert!(MockAudioInterface::new()
                .create_stream(CreateStreamRequest::new())
                .await
                .is_ok());
        }

        #[tokio::test]
        async fn create_stream_error() {
            assert_eq!(
                MockAudioInterface::error("hello from MockAudioInterface")
                    .create_stream(CreateStreamRequest::new())
                    .await
                    .err()
                    .unwrap(),
                "hello from MockAudioInterface"
            );
        }

        #[tokio::test]
        async fn delete_stream_ok() {
            assert!(MockAudioInterface::new()
                .delete_stream(DeleteStreamRequest::new())
                .await
                .is_ok());
        }

        #[tokio::test]
        async fn delete_stream_error() {
            assert_eq!(
                MockAudioInterface::error("hello from MockAudioInterface")
                    .delete_stream(DeleteStreamRequest::new())
                    .await
                    .err()
                    .unwrap(),
                "hello from MockAudioInterface"
            );
        }

        #[tokio::test]
        async fn get_device_info_ok() {
            assert!(MockAudioInterface::new()
                .get_device_info(GetDeviceInfoRequest::new())
                .await
                .is_ok());
        }

        #[tokio::test]
        async fn get_device_info_error() {
            assert_eq!(
                MockAudioInterface::error("hello from MockAudioInterface")
                    .get_device_info(GetDeviceInfoRequest::new())
                    .await
                    .err()
                    .unwrap(),
                "hello from MockAudioInterface"
            );
        }

        #[tokio::test]
        async fn list_streams_ok() {
            assert!(MockAudioInterface::new()
                .list_streams(ListStreamsRequest::new())
                .await
                .is_ok());
        }

        #[tokio::test]
        async fn list_streams_error() {
            assert_eq!(
                MockAudioInterface::error("hello from MockAudioInterface")
                    .list_streams(ListStreamsRequest::new())
                    .await
                    .err()
                    .unwrap(),
                "hello from MockAudioInterface"
            );
        }
    }
}
